@prefix : <http://diggi.io/ontology/dialog#> .
@prefix val: <http://diggi.io/ontology/validation#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# Validation Ontology
<http://diggi.io/ontology/validation> a sh:NodeShape ;
    rdfs:label "Dialog Validation Rules" ;
    rdfs:comment "SHACL validation shapes for dialog answers" .

# Customer Name Validation
val:CustomerNameShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "customer_name" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:minLength 2 ;
        sh:maxLength 100 ;
        sh:pattern "^[A-Za-z\\s'-]+$" ;
        sh:message "Name must contain only letters, spaces, hyphens, and apostrophes" ;
    ] .

# Vehicle Registration Validation (UK format)
val:VehicleRegistrationShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "vehicle_registration" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:pattern "^[A-Z]{2}[0-9]{2}\\s?[A-Z]{3}$|^[A-Z][0-9]{1,3}\\s?[A-Z]{3}$|^[A-Z]{3}\\s?[0-9]{1,3}[A-Z]$|^[0-9]{1,4}\\s?[A-Z]{1,2}$|^[0-9]{1,3}\\s?[A-Z]{1,3}$|^[A-Z]{1,2}\\s?[0-9]{1,4}$|^[A-Z]{1,3}\\s?[0-9]{1,3}$" ;
        sh:message "Invalid UK vehicle registration format" ;
        sh:minLength 2 ;
        sh:maxLength 8 ;
    ] .

# Postcode Validation (UK format)
val:PostcodeShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "postcode" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:pattern "^[A-Z]{1,2}[0-9R][0-9A-Z]?\\s?[0-9][A-Z]{2}$" ;
        sh:message "Invalid UK postcode format" ;
    ] .

# Email Validation
val:EmailShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "email" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:pattern "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$" ;
        sh:message "Invalid email address format" ;
    ] .

# Phone Number Validation (UK format)
val:PhoneNumberShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "phone_number" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:pattern "^(\\+44\\s?7\\d{3}|\\(?07\\d{3}\\)?)\\s?\\d{3}\\s?\\d{3}$|^(\\+44\\s?|0)([1-9]\\d{1,4}|\\d{1}\\s?\\d{3})\\s?\\d{3,4}$" ;
        sh:message "Invalid UK phone number format" ;
    ] .

# Date of Birth Validation
val:DateOfBirthShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "date_of_birth" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:pattern "^(19|20)\\d{2}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])$" ;
        sh:message "Date of birth must be in YYYY-MM-DD format" ;
    ] ;
    sh:property [
        sh:path :answerDate ;
        sh:minInclusive "1900-01-01"^^xsd:date ;
        sh:maxInclusive "2007-01-01"^^xsd:date ;
        sh:message "Driver must be at least 17 years old" ;
    ] .

# Driving License Number Validation (UK format)
val:DrivingLicenseShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "driving_license" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:pattern "^[A-Z]{5}[0-9]{6}[A-Z]{2}[0-9]{3}$" ;
        sh:message "Invalid UK driving license format (e.g., SMITH123456AB1CD)" ;
        sh:length 18 ;
    ] .

# Yes/No Validation
val:YesNoShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :answerType ;
        sh:equals "yes_no" ;
    ] ;
    sh:property [
        sh:path :answerText ;
        sh:in ("yes" "no" "y" "n" "true" "false") ;
        sh:message "Answer must be yes or no" ;
    ] .

# Numeric Range Validation
val:NumericRangeShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :answerType ;
        sh:equals "numeric" ;
    ] ;
    sh:property [
        sh:path :answerNumeric ;
        sh:datatype xsd:decimal ;
    ] .

# Age Validation
val:AgeShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "age" ;
    ] ;
    sh:property [
        sh:path :answerNumeric ;
        sh:minInclusive 17 ;
        sh:maxInclusive 120 ;
        sh:datatype xsd:integer ;
        sh:message "Age must be between 17 and 120" ;
    ] .

# Vehicle Value Validation
val:VehicleValueShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "vehicle_value" ;
    ] ;
    sh:property [
        sh:path :answerNumeric ;
        sh:minInclusive 0 ;
        sh:maxInclusive 500000 ;
        sh:datatype xsd:decimal ;
        sh:message "Vehicle value must be between £0 and £500,000" ;
    ] .

# Years No Claims Validation
val:YearsNoClaimsShape a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:property [
        sh:path :slotName ;
        sh:equals "years_no_claims" ;
    ] ;
    sh:property [
        sh:path :answerNumeric ;
        sh:minInclusive 0 ;
        sh:maxInclusive 50 ;
        sh:datatype xsd:integer ;
        sh:message "Years of no claims must be between 0 and 50" ;
    ] .

# Custom Validation Functions
val:ValidationFunction a rdfs:Class ;
    rdfs:label "Validation Function" ;
    rdfs:comment "Custom validation function definition" .

val:checkLuhnAlgorithm a val:ValidationFunction ;
    rdfs:label "Luhn Algorithm Check" ;
    rdfs:comment "Validates numbers using Luhn algorithm (for credit cards, etc.)" ;
    val:functionCode """
def luhn_check(number):
    def digits_of(n):
        return [int(d) for d in str(n)]
    digits = digits_of(number)
    odd_digits = digits[-1::-2]
    even_digits = digits[-2::-2]
    checksum = sum(odd_digits)
    for d in even_digits:
        checksum += sum(digits_of(d*2))
    return checksum % 10 == 0
""" .

val:checkDVLAFormat a val:ValidationFunction ;
    rdfs:label "DVLA License Format Check" ;
    rdfs:comment "Validates UK driving license number format and checksum" ;
    val:functionCode """
def dvla_check(license_number):
    if len(license_number) != 18:
        return False
    # First 5 characters: surname (padded with 9s)
    surname = license_number[0:5]
    if not surname.isalpha():
        return False
    # Characters 6-7: decade of birth
    decade = license_number[5:7]
    if not decade.isdigit():
        return False
    # Character 8: month of birth (add 5 for female)
    month = license_number[7]
    if not month.isdigit() or int(month) > 5:
        return False
    # And so on...
    return True
""" .

# Cross-field Validation
val:CrossFieldValidation a sh:NodeShape ;
    rdfs:label "Cross-field Validation" ;
    rdfs:comment "Validations that depend on multiple fields" .

val:AgeMatchesDOB a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:sparql [
        sh:message "Age must match date of birth" ;
        sh:select """
            PREFIX : <http://diggi.io/ontology/dialog#>
            SELECT $this
            WHERE {
                $this :slotName "age" ;
                      :answerNumeric ?age .
                ?dob :slotName "date_of_birth" ;
                     :answerDate ?dobDate .
                FILTER(abs(?age - (year(now()) - year(?dobDate))) > 1)
            }
        """ ;
    ] .

val:PostcodeMatchesRegion a sh:NodeShape ;
    sh:targetClass :Answer ;
    sh:sparql [
        sh:message "Postcode must match selected region" ;
        sh:select """
            PREFIX : <http://diggi.io/ontology/dialog#>
            SELECT $this
            WHERE {
                $this :slotName "postcode" ;
                      :answerText ?postcode .
                ?region :slotName "uk_region" ;
                        :answerText ?regionName .
                FILTER NOT EXISTS {
                    # Region-specific postcode validation logic
                    # Scotland: postcode starts with certain letters
                    # etc.
                }
            }
        """ ;
    ] .

# Ontology Structure Validation
# Ensures questions have exactly one :inSection and one :order value

val:QuestionStructureShape a sh:NodeShape ;
    rdfs:label "Question Structure Validation" ;
    rdfs:comment "Ensures each question has exactly one section and order value" ;
    sh:targetClass <http://example.org/multimodal#MultimodalQuestion> ;
    sh:property [
        sh:path :inSection ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "Each question must have exactly one :inSection value" ;
    ] ;
    sh:property [
        sh:path :order ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:datatype xsd:integer ;
        sh:message "Each question must have exactly one :order value (integer)" ;
    ] .
